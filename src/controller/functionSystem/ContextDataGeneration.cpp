#include "controller/functionSystem/ContextDataGeneration.h"
#include "controller/Controller.h"
#include "controller/ControllerContext.h"
#include "controller/ControlListener.h"
#include "controller/controls/ControlFunction.h"
#include "models/graph/TagNode.h"
#include "models/graph/SimpleMeasureNode.h"
#include "models/graph/PolylineMeasureNode.h"
#include "models/graph/GraphManager.hxx"

#include "utils/Logger.h"
#include "utils/ColorConversion.h"

ContextDataGeneration::ContextDataGeneration(const ContextId& id)
    : AContext(id)
{
    m_state = ContextState::ready_for_using;
}

ContextDataGeneration::~ContextDataGeneration()
{
}

ContextState ContextDataGeneration::start(Controller& controller)
{
    return m_state;
}

ContextState ContextDataGeneration::feedMessage(IMessage* message, Controller& controller)
{
    return m_state;
}

ContextState ContextDataGeneration::launch(Controller& controller)
{
    FUNCLOG << "ContextDataGeneration launch" << LOGENDL;
    std::unordered_set<SafePtr<AGraphNode>> new_nodes;
    /*
    // Crée 1000 tags répartis sur une grille (X, Z)
    for (int i = -25; i < 25; ++i)
    {
        for (int j = 0; j < 20; ++j)
        {
            SafePtr<TagNode> tag = make_safe<TagNode>();
            {
                WritePtr<TagNode> wTag = tag.get();
                if (!wTag)
                    continue;

                wTag->setDefaultData(controller);

                glm::dvec3 pos(i * 1.0, -25.0, j * 1.5);
                wTag->setPosition(pos);

                float hue = (rand() % 240) / 240.f;
                glm::vec3 rgb(utils::color::hsl2rgb(glm::vec3(hue, 0.9f, 0.5f)));
                wTag->setColor(Color32(rgb));
                wTag->setMarkerIcon(scs::MarkerIcon::Tag_Cone);
                time_t timeNow;
                wTag->setCreationTime(time(&timeNow));
            }
            new_nodes.insert(tag);
        }
    }
    */

    // Crée 1000 mesures de différents types. 3000 Segments au total
    // 200 SimpleMeasure
    for (int i = 0; i < 200; ++i)
    {
        double i_x = i % 100 * 1.0;
        double i_y = i / 100 * 10.0;
        glm::dvec3 start(i_x, i_y, 0.0);
        glm::dvec3 end = start + glm::dvec3(0.0, 5.0, i * 0.025);

        SafePtr<SimpleMeasureNode> measure = make_safe<SimpleMeasureNode>();
        {
            WritePtr<SimpleMeasureNode> wMeasure = measure.get();
            if (!wMeasure)
                continue;

            wMeasure->setDefaultData(controller);
            wMeasure->setCreationTime(time(nullptr));
            wMeasure->setOriginPos(start);
            wMeasure->setDestinationPos(end);
        }
        new_nodes.insert(measure);
    }

    // 800 PolylineMeasure (200 2sg, 200 3sg, 200 4sg, 200 5sg)
    for (int i = 0; i < 800; ++i)
    {
        int segmentCount = 2 + (i / 200); // 2, 3, 4 or 5 segments
        double i_x = i % 100 * 1.0;
        double i_y = (i % 200) / 100 * 10.0;

        SafePtr<PolylineMeasureNode> measure = make_safe<PolylineMeasureNode>();
        {
            WritePtr<PolylineMeasureNode> wMeasure = measure.get();
            if (!wMeasure)
                continue;

            wMeasure->setDefaultData(controller);
            wMeasure->setCreationTime(time(nullptr));
            for (int j = 0; j < segmentCount; ++j)
            {
                glm::dvec3 P1(i_x + (j % 2) * 1.0, i_y + j * 1.0, segmentCount * 5.0);
                // On étend en zigzag
                glm::dvec3 P2 = P1 + glm::dvec3((1.0 - (j % 2) * 2.0), 1.0, 0.0);
                Measure m = { P1, P2 };
                wMeasure->addMeasure(m);
            }
        }
        new_nodes.insert(measure);
    }

    controller.getControlListener()->notifyUIControl(new control::function::AddNodes(new_nodes));
    return (m_state = ContextState::done);
}

bool ContextDataGeneration::canAutoRelaunch() const
{
    return (false);
}

ContextType ContextDataGeneration::getType() const
{
    return (ContextType::autoGenerateData);
}
